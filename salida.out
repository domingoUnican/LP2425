Grammar:

Rule 0     S' -> expression
Rule 1     expression -> expression + expression
Rule 2     expression -> INT_CONST

Unused terminals:

    THEN
    POOL
    ISVOID
    IF
    IN
    CASE
    ELSE
    STR_CONST
    INHERITS
    WHILE
    FI
    TYPEID
    ESAC
    LOOP
    OBJECTID
    OF
    DARROW
    BOOL_CONST
    NOT
    LET
    CLASS
    ASSIGN
    LE
    NEW

Terminals, with rules where they appear:

+                    : 1
ASSIGN               : 
BOOL_CONST           : 
CASE                 : 
CLASS                : 
DARROW               : 
ELSE                 : 
ESAC                 : 
FI                   : 
IF                   : 
IN                   : 
INHERITS             : 
INT_CONST            : 2
ISVOID               : 
LE                   : 
LET                  : 
LOOP                 : 
NEW                  : 
NOT                  : 
OBJECTID             : 
OF                   : 
POOL                 : 
STR_CONST            : 
THEN                 : 
TYPEID               : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear:

expression           : 1 1 0


state 0

    (0) S' -> . expression
    (1) expression -> . expression + expression
    (2) expression -> . INT_CONST
    INT_CONST       shift and go to state 2

    expression                     shift and go to state 1

state 1

    (0) S' -> expression .
    (1) expression -> expression . + expression
    +               shift and go to state 3


state 2

    (2) expression -> INT_CONST .
    +               reduce using rule 2 (expression -> INT_CONST .)
    $end            reduce using rule 2 (expression -> INT_CONST .)


state 3

    (1) expression -> expression + . expression
    (1) expression -> . expression + expression
    (2) expression -> . INT_CONST
    INT_CONST       shift and go to state 2

    expression                     shift and go to state 4

state 4

    (1) expression -> expression + expression .
    (1) expression -> expression . + expression
  ! shift/reduce conflict for + resolved as shift
    $end            reduce using rule 1 (expression -> expression + expression .)
    +               shift and go to state 3


Conflicts:

shift/reduce conflict for + in state 4 resolved as shift